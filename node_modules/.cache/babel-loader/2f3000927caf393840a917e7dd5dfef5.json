{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Transition = exports.TransitionWithoutForwardingRef = exports.EXITED = exports.EXITING = exports.ENTERED = exports.ENTERING = exports.UNMOUNTED = exports.TransitionFade = void 0;\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar _styledComponents = _interopRequireWildcard(require(\"styled-components\"));\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _templateObject5() {\n  var data = _taggedTemplateLiteral([\"\\n          visibility: hidden;\\n          opacity: 0;\\n        \"]);\n\n  _templateObject5 = function _templateObject5() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject4() {\n  var data = _taggedTemplateLiteral([\"\\n          visibility: visible;\\n          opacity: 1;\\n        \"]);\n\n  _templateObject4 = function _templateObject4() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject3() {\n  var data = _taggedTemplateLiteral([\"\\n      transition: visibility \", \"ms \", \" \", \"ms,\\n        opacity \", \"ms \", \" \", \"ms;\\n      \"]);\n\n  _templateObject3 = function _templateObject3() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject2() {\n  var data = _taggedTemplateLiteral([\"\\n      display: none;\\n    \"]);\n\n  _templateObject2 = function _templateObject2() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject() {\n  var data = _taggedTemplateLiteral([\"\\n  \", \"\\n\\n  \", \"\\n\\n  \", \"\\n\"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _taggedTemplateLiteral(strings, raw) {\n  if (!raw) {\n    raw = strings.slice(0);\n  }\n\n  return Object.freeze(Object.defineProperties(strings, {\n    raw: {\n      value: Object.freeze(raw)\n    }\n  }));\n}\n\nvar getDelay = function getDelay(_ref) {\n  var delay = _ref.delay;\n  return delay || 0;\n};\n\nvar getDuration = function getDuration(_ref2) {\n  var duration = _ref2.duration;\n  return duration || 500;\n};\n\nvar getTimingFunction = function getTimingFunction(_ref3) {\n  var timingFunc = _ref3.timingFunc;\n  return timingFunc || 'ease-out';\n};\n\nvar getStatusChangeDelay = function getStatusChangeDelay(props) {\n  return getDelay(props) + getDuration(props);\n}; // TransitionFade is default transition component using\n// opacity and visibility.\n\n\nvar TransitionFade = _styledComponents.default.div(_templateObject(), function (props) {\n  return props.hidden ? (0, _styledComponents.css)(_templateObject2()) : null;\n}, function (props) {\n  return props.transition ? (0, _styledComponents.css)(_templateObject3(), getDuration, getTimingFunction, getDelay, getDuration, getTimingFunction, getDelay) : '';\n}, function (props) {\n  return props.visible ? (0, _styledComponents.css)(_templateObject4()) : (0, _styledComponents.css)(_templateObject5());\n});\n\nexports.TransitionFade = TransitionFade;\nvar UNMOUNTED = 'unmounted';\nexports.UNMOUNTED = UNMOUNTED;\nvar ENTERING = 'entering';\nexports.ENTERING = ENTERING;\nvar ENTERED = 'entered';\nexports.ENTERED = ENTERED;\nvar EXITING = 'exiting';\nexports.EXITING = EXITING;\nvar EXITED = 'exited';\nexports.EXITED = EXITED;\n\nvar TransitionWithoutForwardingRef =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inherits(TransitionWithoutForwardingRef, _React$Component);\n\n  function TransitionWithoutForwardingRef(props) {\n    var _this;\n\n    _classCallCheck(this, TransitionWithoutForwardingRef);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(TransitionWithoutForwardingRef).call(this, props));\n    _this.state = {\n      status: UNMOUNTED,\n      initiallyVisible: !props.hidden\n    };\n    _this.refTransition = _this.props.innerRef || _react.default.createRef();\n    _this.nextCallback = null;\n    return _this;\n  }\n\n  _createClass(TransitionWithoutForwardingRef, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var _this2 = this;\n\n      var initiallyVisible = this.state.initiallyVisible;\n      var noInitialEnter = this.props.noInitialEnter;\n\n      if (initiallyVisible) {\n        if (noInitialEnter) {\n          // eslint-disable-next-line react/no-did-mount-set-state\n          this.setState({\n            status: ENTERED\n          });\n        } else {\n          this.forceUpdate(); // eslint-disable-next-line react/no-did-mount-set-state\n\n          this.setState({\n            status: ENTERING\n          }, function () {\n            _this2.setNextCallback(function () {\n              return _this2.setState({\n                status: ENTERED\n              });\n            }, getStatusChangeDelay(_this2.props));\n          });\n        }\n      } else {\n        // eslint-disable-next-line react/no-did-mount-set-state\n        this.setState({\n          status: EXITED\n        });\n      }\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      var _this3 = this;\n\n      var _this$props = this.props,\n          noEnter = _this$props.noEnter,\n          noExit = _this$props.noExit,\n          hideOnExit = _this$props.hideOnExit;\n      var nextStatus = null;\n      var nextStatusCallback = null;\n\n      if (prevProps !== this.props) {\n        var status = this.state.status;\n\n        if (this.props.hidden) {\n          if (status === ENTERING || status === ENTERED) {\n            if (noExit) {\n              nextStatus = EXITED;\n            } else {\n              nextStatus = EXITING;\n\n              nextStatusCallback = function nextStatusCallback() {\n                return _this3.setState({\n                  status: EXITED\n                });\n              };\n            }\n          }\n        } else if (status === EXITING || status === EXITED) {\n          if (noEnter) {\n            nextStatus = ENTERED;\n          } else if (hideOnExit) {\n            // If we were hidden (display: none), then we should first render\n            // component with normal display.\n            // This special case renders components without hidden, then renders\n            // it with as visible, and after transition it will update status\n            // to ENTERED.\n            // eslint-disable-next-line react/no-did-update-set-state\n            this.setState({\n              status: UNMOUNTED\n            }, function () {\n              _this3.setNextCallback(function () {\n                return _this3.setState({\n                  status: ENTERING\n                }, function () {\n                  _this3.setNextCallback(function () {\n                    return _this3.setState({\n                      status: ENTERED\n                    });\n                  }, getStatusChangeDelay(_this3.props));\n                });\n              }, 0);\n            });\n            return;\n          } else {\n            nextStatus = ENTERING;\n\n            nextStatusCallback = function nextStatusCallback() {\n              return _this3.setState({\n                status: ENTERED\n              });\n            };\n          }\n        }\n      }\n\n      if (nextStatus != null) {\n        // eslint-disable-next-line react/no-did-update-set-state\n        this.setState({\n          status: nextStatus\n        }, function () {\n          _this3.setNextCallback(nextStatusCallback, getStatusChangeDelay(_this3.props));\n        });\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (this.nextCallback != null) {\n        this.nextCallback.cancel();\n      }\n    }\n  }, {\n    key: \"setNextCallback\",\n    value: function setNextCallback(callback, delay) {\n      var _this4 = this; // This method helps to avoid multiple simultaneous callbacks. It clears\n      // alreadu set callbacks and schedules new one.\n\n\n      if (this.nextCallback != null) {\n        this.nextCallback.cancel();\n      }\n\n      var active = true;\n\n      this.nextCallback = function () {\n        if (!active) {\n          return;\n        }\n\n        active = false;\n        _this4.nextCallback = null;\n\n        if (callback != null) {\n          callback();\n        }\n      };\n\n      this.nextCallback.cancel = function () {\n        active = false;\n      };\n\n      setTimeout(this.nextCallback, delay);\n      return this.nextCallback;\n    }\n  }, {\n    key: \"forceUpdate\",\n    value: function forceUpdate() {\n      // Force repaint for transitions to work\n      // eslint-disable-next-line no-unused-expressions\n      this.refTransition.current && this.refTransition.current.scrollTop;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props2 = this.props,\n          innerRef = _this$props2.innerRef,\n          TransitionComponent = _this$props2.TransitionComponent,\n          children = _this$props2.children,\n          noExit = _this$props2.noExit,\n          noEnter = _this$props2.noEnter,\n          noInitialEnter = _this$props2.noInitialEnter,\n          hideOnExit = _this$props2.hideOnExit,\n          transitionProps = _objectWithoutProperties(_this$props2, [\"innerRef\", \"TransitionComponent\", \"children\", \"noExit\", \"noEnter\", \"noInitialEnter\", \"hideOnExit\"]);\n\n      var status = this.state.status;\n      delete transitionProps.hidden;\n      /* We can't use `hidden` as it just hides element */\n\n      transitionProps.hidden = status === EXITED && hideOnExit;\n      transitionProps.visible = status === ENTERING || status === ENTERED ? 1 : 0;\n      transitionProps.transition = (status === ENTERING || status === ENTERED) && !noEnter || (status === EXITING || status === EXITED) && !noExit ? 1 : 0;\n      return _react.default.createElement(TransitionComponent, _extends({\n        ref: this.refTransition\n      }, transitionProps), children);\n    }\n  }]);\n\n  return TransitionWithoutForwardingRef;\n}(_react.default.Component);\n\nexports.TransitionWithoutForwardingRef = TransitionWithoutForwardingRef;\nTransitionWithoutForwardingRef.defaultProps = {\n  TransitionComponent: TransitionFade\n};\n\nvar Transition = _react.default.forwardRef(function (props, ref) {\n  return _react.default.createElement(TransitionWithoutForwardingRef, _extends({\n    innerRef: ref\n  }, props));\n});\n\nexports.Transition = Transition;","map":null,"metadata":{},"sourceType":"script"}